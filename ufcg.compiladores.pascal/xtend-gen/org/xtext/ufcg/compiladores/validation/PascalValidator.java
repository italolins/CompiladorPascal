/**
 * generated by Xtext 2.11.0.RC2
 */
package org.xtext.ufcg.compiladores.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.xtext.ufcg.compiladores.pascal.PascalFactory;
import org.xtext.ufcg.compiladores.pascal.PascalPackage;
import org.xtext.ufcg.compiladores.pascal.abstraction_declaration;
import org.xtext.ufcg.compiladores.pascal.abstraction_heading;
import org.xtext.ufcg.compiladores.pascal.any_number;
import org.xtext.ufcg.compiladores.pascal.array_type;
import org.xtext.ufcg.compiladores.pascal.assignment_statement;
import org.xtext.ufcg.compiladores.pascal.block;
import org.xtext.ufcg.compiladores.pascal.compound_statement;
import org.xtext.ufcg.compiladores.pascal.conformant_array_schema;
import org.xtext.ufcg.compiladores.pascal.constant;
import org.xtext.ufcg.compiladores.pascal.constant_definition;
import org.xtext.ufcg.compiladores.pascal.constant_definition_part;
import org.xtext.ufcg.compiladores.pascal.declaration_part;
import org.xtext.ufcg.compiladores.pascal.expression;
import org.xtext.ufcg.compiladores.pascal.expression_list;
import org.xtext.ufcg.compiladores.pascal.factor;
import org.xtext.ufcg.compiladores.pascal.file_type;
import org.xtext.ufcg.compiladores.pascal.formal_parameter_list;
import org.xtext.ufcg.compiladores.pascal.formal_parameter_section;
import org.xtext.ufcg.compiladores.pascal.function_designator;
import org.xtext.ufcg.compiladores.pascal.identifier_list;
import org.xtext.ufcg.compiladores.pascal.number;
import org.xtext.ufcg.compiladores.pascal.packed_conformant_array_schema;
import org.xtext.ufcg.compiladores.pascal.parameter_type;
import org.xtext.ufcg.compiladores.pascal.pointer_type;
import org.xtext.ufcg.compiladores.pascal.procedure_and_function_declaration_part;
import org.xtext.ufcg.compiladores.pascal.program;
import org.xtext.ufcg.compiladores.pascal.program_heading;
import org.xtext.ufcg.compiladores.pascal.record_type;
import org.xtext.ufcg.compiladores.pascal.repeat_statement;
import org.xtext.ufcg.compiladores.pascal.repetitive_statement;
import org.xtext.ufcg.compiladores.pascal.set;
import org.xtext.ufcg.compiladores.pascal.set_type;
import org.xtext.ufcg.compiladores.pascal.simple_expression;
import org.xtext.ufcg.compiladores.pascal.simple_statement;
import org.xtext.ufcg.compiladores.pascal.simple_type;
import org.xtext.ufcg.compiladores.pascal.statement;
import org.xtext.ufcg.compiladores.pascal.statement_part;
import org.xtext.ufcg.compiladores.pascal.statement_sequence;
import org.xtext.ufcg.compiladores.pascal.structured_statement;
import org.xtext.ufcg.compiladores.pascal.structured_type;
import org.xtext.ufcg.compiladores.pascal.term;
import org.xtext.ufcg.compiladores.pascal.type;
import org.xtext.ufcg.compiladores.pascal.type_definition;
import org.xtext.ufcg.compiladores.pascal.type_definition_part;
import org.xtext.ufcg.compiladores.pascal.unpacked_conformant_array_schema;
import org.xtext.ufcg.compiladores.pascal.unpacked_structured_type;
import org.xtext.ufcg.compiladores.pascal.value_parameter_section;
import org.xtext.ufcg.compiladores.pascal.variable;
import org.xtext.ufcg.compiladores.pascal.variable_declaration_part;
import org.xtext.ufcg.compiladores.pascal.variable_identifier_list;
import org.xtext.ufcg.compiladores.pascal.variable_parameter_section;
import org.xtext.ufcg.compiladores.pascal.variable_section;
import org.xtext.ufcg.compiladores.validation.APIProvider;
import org.xtext.ufcg.compiladores.validation.AbstractPascalValidator;
import org.xtext.ufcg.compiladores.validation.AdaptativeHashMap;
import org.xtext.ufcg.compiladores.validation.AdaptativeTreeSet;
import org.xtext.ufcg.compiladores.validation.ComposedType;
import org.xtext.ufcg.compiladores.validation.ComposedTypeKind;
import org.xtext.ufcg.compiladores.validation.Element;
import org.xtext.ufcg.compiladores.validation.ElementType;
import org.xtext.ufcg.compiladores.validation.ErrorType;
import org.xtext.ufcg.compiladores.validation.Function;
import org.xtext.ufcg.compiladores.validation.Procedure;
import org.xtext.ufcg.compiladores.validation.Type;
import org.xtext.ufcg.compiladores.validation.TypeInferer;
import org.xtext.ufcg.compiladores.validation.Variable;

@SuppressWarnings("all")
public class PascalValidator extends AbstractPascalValidator {
  private final String NIL = "nil";
  
  private final String RECORD = "record";
  
  private final String CHAR = "char";
  
  private final String BOOLEAN = "boolean";
  
  private final String INTEGER = "integer";
  
  private final String REAL = "real";
  
  private final String POINTER = "^";
  
  private final String ARRAY = "array of ";
  
  private final String UNDEFINED_TYPE_MESSAGE = "Undefined type";
  
  private final String CANNOT_CONVERT_MESSAGE = "Cannot convert ";
  
  private final String TO_MESSAGE = " to ";
  
  private final String IDENTIFIER_IS_ALREADY_BEING_USED = "Identifier is already being used by a ";
  
  private final String WRONG_NUMBER_OF_ARGUMENTS = "Wrong number of arguments. It expected ";
  
  private final String FUNCTION_WAS_NOT_DECLARED = "Function was not declared.";
  
  private final String PROCEDURE_WAS_NOT_DECLARED = "Procedure was not declared.";
  
  private final String VARIABLE_IS_NOT_A_NUMBER = "Variable is not a number.";
  
  private final String CANNOT_CONVERT_TYPE = "Cannot convert type ";
  
  private final String ONLY_CONSTANTS_ARE_ALLOWED = "Only constants are allowed.";
  
  private final String CONSTANTS_CANNOT_BE_ASSIGNED = "Constants cannot be assigned.";
  
  private final String VARIABLE_WAS_NOT_DECLARED = "Variable was not declared.";
  
  private final String INVALID_OPERATOR_FOR_BOOLEAN = "Invalid operator for boolean.";
  
  public final static Map<String, Map<String, Object>> tabela_de_simbolos = new HashMap<String, Map<String, Object>>();
  
  private final Map<EObject, Set<org.xtext.ufcg.compiladores.validation.Error>> ListaDeErros = new AdaptativeHashMap<EObject, org.xtext.ufcg.compiladores.validation.Error>();
  
  private final Map<block, Set<Variable>> variables = new AdaptativeHashMap<block, Variable>();
  
  private final Map<block, Set<Procedure>> abstracoes = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
  
  private final Map<block, Set<Type>> types = new AdaptativeHashMap<block, Type>(APIProvider.types);
  
  private final Map<EObject, Type> calculatedTypes = new HashMap<EObject, Type>();
  
  public static <T extends Element> T search(final Set<T> elements, final T key) {
    for (final T t : elements) {
      boolean _equals = t.equals(key);
      if (_equals) {
        return t;
      }
    }
    return null;
  }
  
  public static Procedure searchWithTypeCoersion(final Set<Procedure> elements, final Procedure key) {
    Procedure optimal = null;
    for (final Procedure t : elements) {
      {
        boolean _equals = t.equals(key);
        if (_equals) {
          return t;
        }
        boolean _equalsWithTypeCoersion = t.equalsWithTypeCoersion(key);
        if (_equalsWithTypeCoersion) {
          optimal = t;
        }
      }
    }
    return optimal;
  }
  
  public static Type procuraPorNome(final Set<Type> types, final Type key) {
    for (final Type t : types) {
      String _lowerCase = t.name.toLowerCase();
      String _lowerCase_1 = key.name.toLowerCase();
      boolean _equals = _lowerCase.equals(_lowerCase_1);
      if (_equals) {
        return t;
      }
    }
    return null;
  }
  
  public boolean insertError(final EObject object, final String message, final ErrorType type, final EStructuralFeature feature) {
    Set<org.xtext.ufcg.compiladores.validation.Error> _get = this.ListaDeErros.get(object);
    org.xtext.ufcg.compiladores.validation.Error _error = new org.xtext.ufcg.compiladores.validation.Error(message, type, feature);
    return _get.add(_error);
  }
  
  public void removeError(final EObject object, final ErrorType type) {
    Set<org.xtext.ufcg.compiladores.validation.Error> _get = this.ListaDeErros.get(object);
    org.xtext.ufcg.compiladores.validation.Error _error = new org.xtext.ufcg.compiladores.validation.Error(type);
    _get.remove(_error);
    this.showError(object);
  }
  
  public <T extends Element> Set<T> clear(final block b, final ElementType type, final Map<block, Set<T>> container) {
    Set<T> _xblockexpression = null;
    {
      AdaptativeTreeSet<T> newSet = new AdaptativeTreeSet<T>();
      Set<T> _get = container.get(b);
      for (final T t : _get) {
        if (((!Objects.equal(t.type, type)) || t.isInherited())) {
          newSet.add(t);
        }
      }
      _xblockexpression = container.put(b, newSet);
    }
    return _xblockexpression;
  }
  
  public ArrayList<Variable> getParameters(final block b, final function_designator f) {
    ArrayList<Variable> parameters = new ArrayList<Variable>();
    expression_list _expressions = f.getExpressions();
    boolean _notEquals = (!Objects.equal(_expressions, null));
    if (_notEquals) {
      int count = 0;
      expression_list _expressions_1 = f.getExpressions();
      EList<expression> _expressions_2 = _expressions_1.getExpressions();
      for (final expression e : _expressions_2) {
        {
          Type _type = this.getType(b, e);
          Variable _variable = new Variable(("arg_" + Integer.valueOf(count)), _type, false, b, ElementType.PARAMETER);
          parameters.add(_variable);
          count++;
        }
      }
    }
    return parameters;
  }
  
  public Procedure getAbstraction(final block b, final function_designator f) {
    String name = f.getName();
    ArrayList<Variable> parameters = this.getParameters(b, f);
    return new Procedure(name, parameters);
  }
  
  public String getRealType(final block b, final String type) {
    Set<Type> _get = this.types.get(b);
    Type _type = new Type(type);
    Type foundType = PascalValidator.<Type>search(_get, _type);
    boolean _notEquals = (!Objects.equal(foundType, null));
    if (_notEquals) {
      return foundType.getRealType();
    }
    return type;
  }
  
  public Type getType(final block b, final String type) {
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      return null;
    }
    if (((type.length() > 1) && type.substring(0, 1).equals(this.POINTER))) {
      String _substring = type.substring(1);
      Type _type = this.getType(b, _substring);
      return new ComposedType(_type, ComposedTypeKind.POINTER);
    } else {
      if (((type.length() > 9) && type.substring(0, 9).equals(this.ARRAY))) {
        String _substring_1 = type.substring(9);
        Type _type_1 = this.getType(b, _substring_1);
        return new ComposedType(_type_1, ComposedTypeKind.ARRAY);
      }
    }
    String _realType = this.getRealType(b, type);
    return new Type(type, false, _realType);
  }
  
  public Type getComposedType(final block b, final String type, final ComposedTypeKind kind) {
    Type _type = this.getType(b, type);
    return new ComposedType(_type, kind);
  }
  
  public Type getType(final block b, final type t) {
    Type type = new Type(this.NIL);
    simple_type _simple = t.getSimple();
    boolean _notEquals = (!Objects.equal(_simple, null));
    if (_notEquals) {
      simple_type simple = t.getSimple();
      if (((!Objects.equal(simple.getSubrange(), null)) || (!Objects.equal(simple.getEnumerated(), null)))) {
        Type _type = new Type("enumerated", false, "...enumerated");
        type = _type;
      } else {
        String _name = simple.getName();
        boolean _notEquals_1 = (!Objects.equal(_name, null));
        if (_notEquals_1) {
          Set<Type> _get = this.types.get(b);
          String _name_1 = simple.getName();
          Type _type_1 = new Type(_name_1);
          Type _search = PascalValidator.<Type>search(_get, _type_1);
          boolean _equals = Objects.equal(_search, null);
          if (_equals) {
            this.insertError(t, this.UNDEFINED_TYPE_MESSAGE, ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
          } else {
            this.removeError(t, ErrorType.UNDEFINED_TYPE);
          }
          String _name_2 = simple.getName();
          Type _type_2 = this.getType(b, _name_2);
          type = _type_2;
        }
      }
    } else {
      structured_type _structured = t.getStructured();
      boolean _notEquals_2 = (!Objects.equal(_structured, null));
      if (_notEquals_2) {
        structured_type structured = t.getStructured();
        unpacked_structured_type unpacked = structured.getType();
        array_type _array = unpacked.getArray();
        boolean _notEquals_3 = (!Objects.equal(_array, null));
        if (_notEquals_3) {
          array_type _array_1 = unpacked.getArray();
          org.xtext.ufcg.compiladores.pascal.type _type_3 = _array_1.getType();
          Type _type_4 = this.getType(b, _type_3);
          ComposedType _composedType = new ComposedType(_type_4, ComposedTypeKind.ARRAY);
          type = _composedType;
        } else {
          record_type _record = unpacked.getRecord();
          boolean _notEquals_4 = (!Objects.equal(_record, null));
          if (_notEquals_4) {
            Type _type_5 = new Type(this.RECORD);
            type = _type_5;
          } else {
            set_type _set = unpacked.getSet();
            boolean _notEquals_5 = (!Objects.equal(_set, null));
            if (_notEquals_5) {
              set_type _set_1 = unpacked.getSet();
              org.xtext.ufcg.compiladores.pascal.type _type_6 = _set_1.getType();
              Type _type_7 = this.getType(b, _type_6);
              type = _type_7;
            } else {
              file_type _file = unpacked.getFile();
              boolean _notEquals_6 = (!Objects.equal(_file, null));
              if (_notEquals_6) {
                file_type _file_1 = unpacked.getFile();
                org.xtext.ufcg.compiladores.pascal.type _type_8 = _file_1.getType();
                Type _type_9 = this.getType(b, _type_8);
                type = _type_9;
              }
            }
          }
        }
      } else {
        pointer_type _pointer = t.getPointer();
        boolean _notEquals_7 = (!Objects.equal(_pointer, null));
        if (_notEquals_7) {
          pointer_type _pointer_1 = t.getPointer();
          org.xtext.ufcg.compiladores.pascal.type _type_10 = _pointer_1.getType();
          Type _type_11 = this.getType(b, _type_10);
          ComposedType _composedType_1 = new ComposedType(_type_11, ComposedTypeKind.POINTER);
          type = _composedType_1;
        }
      }
    }
    return type;
  }
  
  public Type getType(final block b, final parameter_type type) {
    Type t = new Type(this.NIL);
    conformant_array_schema _array = type.getArray();
    boolean _notEquals = (!Objects.equal(_array, null));
    if (_notEquals) {
      conformant_array_schema array = type.getArray();
      packed_conformant_array_schema _packed = array.getPacked();
      boolean _notEquals_1 = (!Objects.equal(_packed, null));
      if (_notEquals_1) {
        packed_conformant_array_schema _packed_1 = array.getPacked();
        String _name = _packed_1.getName();
        Type _type = this.getType(b, _name);
        ComposedType _composedType = new ComposedType(_type, ComposedTypeKind.ARRAY);
        t = _composedType;
      } else {
        unpacked_conformant_array_schema _unpacked = array.getUnpacked();
        boolean _notEquals_2 = (!Objects.equal(_unpacked, null));
        if (_notEquals_2) {
          unpacked_conformant_array_schema _unpacked_1 = array.getUnpacked();
          parameter_type _type_1 = _unpacked_1.getType();
          Type _type_2 = this.getType(b, _type_1);
          ComposedType _composedType_1 = new ComposedType(_type_2, ComposedTypeKind.ARRAY);
          t = _composedType_1;
        }
      }
    } else {
      String _name_1 = type.getName();
      boolean _notEquals_3 = (!Objects.equal(_name_1, null));
      if (_notEquals_3) {
        Set<Type> _get = this.types.get(b);
        String _name_2 = type.getName();
        Type _type_3 = new Type(_name_2);
        Type _search = PascalValidator.<Type>search(_get, _type_3);
        boolean _equals = Objects.equal(_search, null);
        if (_equals) {
          this.insertError(type, this.UNDEFINED_TYPE_MESSAGE, ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
        } else {
          this.removeError(type, ErrorType.UNDEFINED_TYPE);
        }
        String _name_3 = type.getName();
        Type _type_4 = this.getType(b, _name_3);
        t = _type_4;
      }
    }
    return t;
  }
  
  public Type getType(final block b, final constant const_) {
    Type type = new Type(this.NIL);
    String _name = const_.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      Set<Variable> _get = this.variables.get(b);
      String _name_1 = const_.getName();
      Variable _variable = new Variable(_name_1);
      Variable varFound = PascalValidator.<Variable>search(_get, _variable);
      boolean _notEquals_1 = (!Objects.equal(varFound, null));
      if (_notEquals_1) {
        Type _varType = varFound.getVarType();
        type = _varType;
      }
    } else {
      String _string = const_.getString();
      boolean _notEquals_2 = (!Objects.equal(_string, null));
      if (_notEquals_2) {
        Type _type = new Type(this.CHAR);
        ComposedType _composedType = new ComposedType(_type, ComposedTypeKind.ARRAY);
        type = _composedType;
      } else {
        String _boolLiteral = const_.getBoolLiteral();
        boolean _notEquals_3 = (!Objects.equal(_boolLiteral, null));
        if (_notEquals_3) {
          Type _type_1 = new Type(this.BOOLEAN);
          type = _type_1;
        } else {
          String _nil = const_.getNil();
          boolean _notEquals_4 = (!Objects.equal(_nil, null));
          if (_notEquals_4) {
            Type _type_2 = new Type(this.NIL);
            type = _type_2;
          } else {
            number _number = const_.getNumber();
            boolean _notEquals_5 = (!Objects.equal(_number, null));
            if (_notEquals_5) {
              number _number_1 = const_.getNumber();
              any_number _number_2 = _number_1.getNumber();
              String _integer = _number_2.getInteger();
              boolean _notEquals_6 = (!Objects.equal(_integer, null));
              if (_notEquals_6) {
                Type _type_3 = new Type(this.INTEGER);
                type = _type_3;
              } else {
                number _number_3 = const_.getNumber();
                any_number _number_4 = _number_3.getNumber();
                String _real = _number_4.getReal();
                boolean _notEquals_7 = (!Objects.equal(_real, null));
                if (_notEquals_7) {
                  Type _type_4 = new Type(this.REAL);
                  type = _type_4;
                }
              }
            }
          }
        }
      }
    }
    return type;
  }
  
  public Type getType(final block b, final variable v) {
    Type type = new Type(this.NIL);
    Set<Variable> _get = this.variables.get(b);
    String _name = v.getName();
    Variable _variable = new Variable(_name);
    Variable variableFound = PascalValidator.<Variable>search(_get, _variable);
    boolean _notEquals = (!Objects.equal(variableFound, null));
    if (_notEquals) {
      Type _varType = variableFound.getVarType();
      type = _varType;
    }
    return type;
  }
  
  public Type getType(final block b, final function_designator f) {
    Type type = new Type(this.NIL);
    Procedure function = this.getAbstraction(b, f);
    Set<Procedure> _get = this.abstracoes.get(b);
    Procedure abstractionFound = PascalValidator.searchWithTypeCoersion(_get, function);
    if (((!Objects.equal(abstractionFound, null)) && Objects.equal(abstractionFound.type, ElementType.FUNCTION))) {
      Function functionFound = ((Function) abstractionFound);
      Type _returnType = functionFound.getReturnType();
      type = _returnType;
    }
    return type;
  }
  
  public Type getType(final block b, final factor f) {
    Type type = new Type(this.NIL);
    variable _variable = f.getVariable();
    boolean _notEquals = (!Objects.equal(_variable, null));
    if (_notEquals) {
      Set<Variable> _get = this.variables.get(b);
      variable _variable_1 = f.getVariable();
      String _name = _variable_1.getName();
      Variable _variable_2 = new Variable(_name);
      Variable variableFound = PascalValidator.<Variable>search(_get, _variable_2);
      boolean _notEquals_1 = (!Objects.equal(variableFound, null));
      if (_notEquals_1) {
        Type _varType = variableFound.getVarType();
        type = _varType;
      }
    } else {
      number _number = f.getNumber();
      boolean _notEquals_2 = (!Objects.equal(_number, null));
      if (_notEquals_2) {
        number _number_1 = f.getNumber();
        any_number number = _number_1.getNumber();
        String _integer = number.getInteger();
        boolean _notEquals_3 = (!Objects.equal(_integer, null));
        if (_notEquals_3) {
          Type _type = new Type(this.INTEGER);
          type = _type;
        } else {
          String _real = number.getReal();
          boolean _notEquals_4 = (!Objects.equal(_real, null));
          if (_notEquals_4) {
            Type _type_1 = new Type(this.REAL);
            type = _type_1;
          }
        }
      } else {
        String _string = f.getString();
        boolean _notEquals_5 = (!Objects.equal(_string, null));
        if (_notEquals_5) {
          Type _type_2 = new Type(this.CHAR);
          ComposedType _composedType = new ComposedType(_type_2, ComposedTypeKind.ARRAY);
          type = _composedType;
        } else {
          set _set = f.getSet();
          boolean _notEquals_6 = (!Objects.equal(_set, null));
          if (_notEquals_6) {
            set _set_1 = f.getSet();
            expression_list _expressions = _set_1.getExpressions();
            Type _type_3 = this.getType(b, _expressions, true);
            type = _type_3;
          } else {
            boolean _isNil = f.isNil();
            if (_isNil) {
              Type _type_4 = new Type(this.NIL);
              type = _type_4;
            } else {
              if (((!Objects.equal(f.getBoolean(), null)) || (!Objects.equal(f.getNot(), null)))) {
                Type _type_5 = new Type(this.BOOLEAN);
                type = _type_5;
              } else {
                function_designator _function = f.getFunction();
                boolean _notEquals_7 = (!Objects.equal(_function, null));
                if (_notEquals_7) {
                  function_designator _function_1 = f.getFunction();
                  Type _type_6 = this.getType(b, _function_1);
                  type = _type_6;
                } else {
                  expression _expression = f.getExpression();
                  boolean _notEquals_8 = (!Objects.equal(_expression, null));
                  if (_notEquals_8) {
                    expression _expression_1 = f.getExpression();
                    Type _type_7 = this.getType(b, _expression_1);
                    type = _type_7;
                  }
                }
              }
            }
          }
        }
      }
    }
    this.calculatedTypes.put(f, type);
    return type;
  }
  
  public Type getType(final block b, final term t) {
    Type greatestType = null;
    EList<factor> _factors = t.getFactors();
    for (final factor f : _factors) {
      {
        Type type = this.getType(b, f);
        Type _greater = TypeInferer.greater(type, greatestType);
        greatestType = _greater;
      }
    }
    this.calculatedTypes.put(t, greatestType);
    return greatestType;
  }
  
  public Type getType(final block b, final simple_expression expr) {
    Type greatestType = null;
    EList<EObject> _terms = expr.getTerms();
    for (final EObject obj : _terms) {
      if ((obj instanceof term)) {
        term t = ((term) obj);
        Type type = this.getType(b, t);
        Type _greater = TypeInferer.greater(type, greatestType);
        greatestType = _greater;
      } else {
        any_number n = ((any_number) obj);
        String _integer = n.getInteger();
        boolean _notEquals = (!Objects.equal(_integer, null));
        if (_notEquals) {
          Type _type = new Type(this.INTEGER);
          Type _greater_1 = TypeInferer.greater(_type, greatestType);
          greatestType = _greater_1;
        } else {
          Type _type_1 = new Type(this.REAL);
          Type _greater_2 = TypeInferer.greater(_type_1, greatestType);
          greatestType = _greater_2;
        }
      }
    }
    this.calculatedTypes.put(expr, greatestType);
    return greatestType;
  }
  
  public Type getType(final block b, final expression expr) {
    Type t = new Type(this.NIL);
    if (((!Objects.equal(expr.getOperators(), null)) && (!expr.getOperators().isEmpty()))) {
      Type _type = new Type(this.BOOLEAN);
      t = _type;
    } else {
      Type greatestType = null;
      EList<simple_expression> _expressions = expr.getExpressions();
      for (final simple_expression e : _expressions) {
        {
          Type type = this.getType(b, e);
          Type _greater = TypeInferer.greater(type, greatestType);
          greatestType = _greater;
        }
      }
      t = greatestType;
    }
    this.calculatedTypes.put(expr, t);
    return t;
  }
  
  public Type getType(final block b, final expression_list expr, final boolean isCohese) {
    Type greatestType = null;
    boolean hasErrors = true;
    EList<expression> _expressions = expr.getExpressions();
    for (final expression e : _expressions) {
      {
        Type type = this.getType(b, e);
        if (isCohese) {
          if (((((!Objects.equal(greatestType, null)) && (TypeInferer.getTypeWeight(greatestType) < 0)) && (TypeInferer.getTypeWeight(type) >= 0)) || 
            ((TypeInferer.getTypeWeight(type) < 0) && (TypeInferer.getTypeWeight(greatestType) >= 0)))) {
            this.insertError(expr, ((((this.CANNOT_CONVERT_MESSAGE + type) + this.TO_MESSAGE) + greatestType) + "."), ErrorType.TYPE_COHESION, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
            hasErrors = true;
          }
        }
        Type _greater = TypeInferer.greater(type, greatestType);
        greatestType = _greater;
      }
    }
    if ((!hasErrors)) {
      this.removeError(expr, ErrorType.TYPE_COHESION);
    }
    this.calculatedTypes.put(expr, greatestType);
    return greatestType;
  }
  
  public static Object getValue(final number num) {
    any_number _number = num.getNumber();
    String _integer = _number.getInteger();
    boolean _notEquals = (!Objects.equal(_integer, null));
    if (_notEquals) {
      any_number _number_1 = num.getNumber();
      String _integer_1 = _number_1.getInteger();
      return Integer.valueOf(_integer_1);
    } else {
      any_number _number_2 = num.getNumber();
      String _real = _number_2.getReal();
      boolean _notEquals_1 = (!Objects.equal(_real, null));
      if (_notEquals_1) {
        any_number _number_3 = num.getNumber();
        String _real_1 = _number_3.getReal();
        return Double.valueOf(_real_1);
      }
    }
    return null;
  }
  
  public static boolean isNumeric(final Object obj) {
    try {
      String _string = obj.toString();
      Double.parseDouble(_string);
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    return true;
  }
  
  public static Object getValue(final constant const_, final Set<Variable> variables) {
    Object value = null;
    String _name = const_.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      String _name_1 = const_.getName();
      Variable _variable = new Variable(_name_1);
      Variable variable = PascalValidator.<Variable>search(variables, _variable);
      Object _value = variable.getValue();
      value = _value;
    } else {
      number _number = const_.getNumber();
      boolean _notEquals_1 = (!Objects.equal(_number, null));
      if (_notEquals_1) {
        number _number_1 = const_.getNumber();
        Object _value_1 = PascalValidator.getValue(_number_1);
        value = _value_1;
      } else {
        String _string = const_.getString();
        boolean _notEquals_2 = (!Objects.equal(_string, null));
        if (_notEquals_2) {
          String _string_1 = const_.getString();
          value = _string_1;
        } else {
          String _boolLiteral = const_.getBoolLiteral();
          boolean _notEquals_3 = (!Objects.equal(_boolLiteral, null));
          if (_notEquals_3) {
            String _boolLiteral_1 = const_.getBoolLiteral();
            Boolean _valueOf = Boolean.valueOf(_boolLiteral_1);
            value = _valueOf;
          } else {
            String _nil = const_.getNil();
            boolean _notEquals_4 = (!Objects.equal(_nil, null));
            if (_notEquals_4) {
              value = null;
            }
          }
        }
      }
    }
    String _opterator = const_.getOpterator();
    boolean _notEquals_5 = (!Objects.equal(_opterator, null));
    if (_notEquals_5) {
      if ((PascalValidator.isNumeric(value) && const_.getOpterator().equals("-"))) {
        try {
          String _string_2 = value.toString();
          int _parseInt = Integer.parseInt(_string_2);
          return Integer.valueOf((-_parseInt));
        } catch (final Throwable _t) {
          if (_t instanceof Exception) {
            final Exception e = (Exception)_t;
            String _string_3 = value.toString();
            double _parseDouble = Double.parseDouble(_string_3);
            return Double.valueOf((-_parseDouble));
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      }
    }
    return value;
  }
  
  public <T extends Element> boolean addElementToAbstraction(final abstraction_declaration decl, final T element, final Map<block, Set<T>> container) {
    boolean _xblockexpression = false;
    {
      block _block = decl.getBlock();
      boolean _equals = Objects.equal(_block, null);
      if (_equals) {
        PascalFactory _pascalFactory = PascalPackage.eINSTANCE.getPascalFactory();
        block _createblock = _pascalFactory.createblock();
        decl.setBlock(_createblock);
      }
      block subblock = decl.getBlock();
      Set<T> _get = container.get(subblock);
      _xblockexpression = _get.add(element);
    }
    return _xblockexpression;
  }
  
  public <T extends Element> void inheritElement(final block b, final T element, final Map<block, Set<T>> container) {
    declaration_part _declaration = b.getDeclaration();
    procedure_and_function_declaration_part _abstraction = _declaration.getAbstraction();
    boolean _notEquals = (!Objects.equal(_abstraction, null));
    if (_notEquals) {
      declaration_part _declaration_1 = b.getDeclaration();
      procedure_and_function_declaration_part _abstraction_1 = _declaration_1.getAbstraction();
      EList<abstraction_heading> _procedures = _abstraction_1.getProcedures();
      boolean _notEquals_1 = (!Objects.equal(_procedures, null));
      if (_notEquals_1) {
        declaration_part _declaration_2 = b.getDeclaration();
        procedure_and_function_declaration_part _abstraction_2 = _declaration_2.getAbstraction();
        EList<abstraction_heading> _procedures_1 = _abstraction_2.getProcedures();
        for (final abstraction_declaration procedure : _procedures_1) {
          this.<T>addElementToAbstraction(procedure, element, container);
        }
      }
      declaration_part _declaration_3 = b.getDeclaration();
      procedure_and_function_declaration_part _abstraction_3 = _declaration_3.getAbstraction();
      EList<abstraction_declaration> _functions = _abstraction_3.getFunctions();
      boolean _notEquals_2 = (!Objects.equal(_functions, null));
      if (_notEquals_2) {
        declaration_part _declaration_4 = b.getDeclaration();
        procedure_and_function_declaration_part _abstraction_4 = _declaration_4.getAbstraction();
        EList<abstraction_declaration> _functions_1 = _abstraction_4.getFunctions();
        for (final abstraction_declaration function : _functions_1) {
          this.<T>addElementToAbstraction(function, element, container);
        }
      }
    }
  }
  
  public <T extends Element> Boolean addElement(final block b, final T element, final Map<block, Set<T>> container, final EObject errorSection, final EStructuralFeature errorFeature) {
    boolean _xblockexpression = false;
    {
      T elementFound = null;
      boolean _equals = Objects.equal(container, this.types);
      if (_equals) {
        Type type = ((Type) element);
        Set<Type> _get = this.types.get(b);
        Type _procuraPorNome = PascalValidator.procuraPorNome(_get, type);
        elementFound = ((T) _procuraPorNome);
      } else {
        Set<T> _get_1 = container.get(b);
        T _search = PascalValidator.<T>search(_get_1, element);
        elementFound = _search;
      }
      boolean _xifexpression = false;
      if (((!Objects.equal(elementFound, null)) && (!elementFound.isInherited()))) {
        boolean _xifexpression_1 = false;
        boolean _equals_1 = Objects.equal(element.type, elementFound.type);
        if (_equals_1) {
          String _plus = (element.type + " cannot be redeclared.");
          _xifexpression_1 = this.insertError(errorSection, _plus, ErrorType.REDECLARATION, errorFeature);
        } else {
          boolean _xifexpression_2 = false;
          boolean _equals_2 = Objects.equal(elementFound.type, ElementType.FUNCTION_RETURN);
          if (_equals_2) {
            _xifexpression_2 = this.insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
          } else {
            String _string = elementFound.type.toString();
            String _lowerCase = _string.toLowerCase();
            String _plus_1 = (this.IDENTIFIER_IS_ALREADY_BEING_USED + _lowerCase);
            String _plus_2 = (_plus_1 + ".");
            _xifexpression_2 = this.insertError(errorSection, _plus_2, ErrorType.REDECLARATION, errorFeature);
          }
          _xifexpression_1 = _xifexpression_2;
        }
        _xifexpression = _xifexpression_1;
      } else {
        this.removeError(errorSection, ErrorType.REDECLARATION);
        Set<T> _get_2 = container.get(b);
        _get_2.add(element);
        Element _clone = element.clone();
        T inheritedElement = ((T) _clone);
        inheritedElement.inherited = true;
        this.<T>inheritElement(b, inheritedElement, container);
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  public ArrayList<Variable> getParameters(final block b, final abstraction_heading heading, final block abstractionBlock) {
    ArrayList<Variable> parameters = new ArrayList<Variable>();
    formal_parameter_list _parameters = heading.getParameters();
    boolean _notEquals = (!Objects.equal(_parameters, null));
    if (_notEquals) {
      formal_parameter_list list = heading.getParameters();
      EList<formal_parameter_section> _parameters_1 = list.getParameters();
      boolean _notEquals_1 = (!Objects.equal(_parameters_1, null));
      if (_notEquals_1) {
        EList<formal_parameter_section> _parameters_2 = list.getParameters();
        for (final formal_parameter_section section : _parameters_2) {
          variable_parameter_section _variable = section.getVariable();
          boolean _notEquals_2 = (!Objects.equal(_variable, null));
          if (_notEquals_2) {
            variable_parameter_section variable = section.getVariable();
            identifier_list _identifiers = variable.getIdentifiers();
            EList<String> _ids = _identifiers.getIds();
            for (final String varName : _ids) {
              {
                variable_parameter_section _variable_1 = section.getVariable();
                parameter_type _type = _variable_1.getType();
                Type _type_1 = this.getType(b, _type);
                Variable parameter = new Variable(varName, _type_1, false, abstractionBlock, ElementType.PARAMETER);
                this.<Variable>addElement(b, parameter, this.variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
                parameters.add(parameter);
              }
            }
          } else {
            value_parameter_section _value = section.getValue();
            boolean _notEquals_3 = (!Objects.equal(_value, null));
            if (_notEquals_3) {
              value_parameter_section value = section.getValue();
              identifier_list _identifiers_1 = value.getIdentifiers();
              EList<String> _ids_1 = _identifiers_1.getIds();
              for (final String valName : _ids_1) {
                {
                  parameter_type _type = value.getType();
                  Type _type_1 = this.getType(b, _type);
                  Variable parameter = new Variable(valName, _type_1, false, abstractionBlock, ElementType.PARAMETER);
                  this.<Variable>addElement(b, parameter, this.variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
                  parameters.add(parameter);
                }
              }
            }
          }
        }
      }
    }
    return parameters;
  }
  
  public Boolean addAbstraction(final block b, final abstraction_declaration decl, final abstraction_heading heading) {
    Boolean _xblockexpression = null;
    {
      String name = heading.getName();
      block _block = decl.getBlock();
      boolean _equals = Objects.equal(_block, null);
      if (_equals) {
        PascalFactory _pascalFactory = PascalPackage.eINSTANCE.getPascalFactory();
        block _createblock = _pascalFactory.createblock();
        decl.setBlock(_createblock);
      }
      block _block_1 = decl.getBlock();
      this.<Variable>clear(_block_1, ElementType.PARAMETER, this.variables);
      block _block_2 = decl.getBlock();
      block _block_3 = decl.getBlock();
      ArrayList<Variable> parameters = this.getParameters(_block_2, heading, _block_3);
      boolean forward = decl.isForward();
      String returnType = heading.getResultType();
      Boolean _xifexpression = null;
      boolean _notEquals = (!Objects.equal(returnType, null));
      if (_notEquals) {
        boolean _xblockexpression_1 = false;
        {
          Set<Type> _get = this.types.get(b);
          Type _type = new Type(returnType);
          Type _search = PascalValidator.<Type>search(_get, _type);
          boolean _equals_1 = Objects.equal(_search, null);
          if (_equals_1) {
            this.insertError(heading, this.UNDEFINED_TYPE_MESSAGE, ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RESULT_TYPE);
          } else {
            this.removeError(heading, ErrorType.UNDEFINED_TYPE);
          }
          Type _type_1 = this.getType(b, returnType);
          Function function = new Function(name, forward, b, decl, parameters, forward, _type_1);
          this.<Procedure>addElement(b, function, this.abstracoes, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
          Type _type_2 = this.getType(b, returnType);
          block _block_4 = decl.getBlock();
          Variable returnVariable = new Variable(name, _type_2, false, _block_4, ElementType.FUNCTION_RETURN);
          returnVariable.setOwningFunction(function);
          block _block_5 = decl.getBlock();
          Set<Variable> _get_1 = this.variables.get(_block_5);
          _xblockexpression_1 = _get_1.add(returnVariable);
        }
        _xifexpression = Boolean.valueOf(_xblockexpression_1);
      } else {
        Procedure _procedure = new Procedure(name, forward, b, decl, parameters, forward);
        _xifexpression = this.<Procedure>addElement(b, _procedure, this.abstracoes, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public void checkAbstractionRedeclaration(final block b) {
    declaration_part _declaration = b.getDeclaration();
    procedure_and_function_declaration_part _abstraction = _declaration.getAbstraction();
    boolean _notEquals = (!Objects.equal(_abstraction, null));
    if (_notEquals) {
      this.<Procedure>clear(b, ElementType.FUNCTION, this.abstracoes);
      this.<Procedure>clear(b, ElementType.PROCEDURE, this.abstracoes);
      declaration_part _declaration_1 = b.getDeclaration();
      procedure_and_function_declaration_part abstraction = _declaration_1.getAbstraction();
      EList<abstraction_declaration> _functions = abstraction.getFunctions();
      boolean _notEquals_1 = (!Objects.equal(_functions, null));
      if (_notEquals_1) {
        EList<abstraction_declaration> _functions_1 = abstraction.getFunctions();
        for (final abstraction_declaration function : _functions_1) {
          abstraction_heading _heading = function.getHeading();
          this.addAbstraction(b, function, _heading);
        }
      }
      EList<abstraction_heading> _procedures = abstraction.getProcedures();
      boolean _notEquals_2 = (!Objects.equal(_procedures, null));
      if (_notEquals_2) {
        EList<abstraction_heading> _procedures_1 = abstraction.getProcedures();
        for (final abstraction_declaration procedure : _procedures_1) {
          abstraction_heading _heading_1 = procedure.getHeading();
          this.addAbstraction(b, procedure, _heading_1);
        }
      }
    }
  }
  
  public void checkTypeRedeclaration(final block b) {
    this.<Type>clear(b, ElementType.TYPE, this.types);
    declaration_part _declaration = b.getDeclaration();
    type_definition_part _type_def = _declaration.getType_def();
    boolean _notEquals = (!Objects.equal(_type_def, null));
    if (_notEquals) {
      declaration_part _declaration_1 = b.getDeclaration();
      type_definition_part _type_def_1 = _declaration_1.getType_def();
      EList<type_definition> _types = _type_def_1.getTypes();
      for (final type_definition t : _types) {
        String _name = t.getName();
        type _type = t.getType();
        Type _type_1 = this.getType(b, _type);
        String _realType = _type_1.getRealType();
        Type _type_2 = new Type(_name, false, _realType);
        this.<Type>addElement(b, _type_2, this.types, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
      }
    }
  }
  
  public void checkConstantRedeclaration(final block b) {
    this.<Variable>clear(b, ElementType.CONSTANT, this.variables);
    declaration_part _declaration = b.getDeclaration();
    constant_definition_part _constant_def = _declaration.getConstant_def();
    boolean _notEquals = (!Objects.equal(_constant_def, null));
    if (_notEquals) {
      declaration_part _declaration_1 = b.getDeclaration();
      constant_definition_part _constant_def_1 = _declaration_1.getConstant_def();
      EList<constant_definition> _consts = _constant_def_1.getConsts();
      for (final constant_definition const_ : _consts) {
        String _name = const_.getName();
        constant _const = const_.getConst();
        Type _type = this.getType(b, _const);
        constant _const_1 = const_.getConst();
        Set<Variable> _get = this.variables.get(b);
        Object _value = PascalValidator.getValue(_const_1, _get);
        Variable _variable = new Variable(_name, _type, false, b, ElementType.CONSTANT, _value);
        this.<Variable>addElement(b, _variable, this.variables, const_, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
      }
    }
  }
  
  public void checkVariableRedeclaration(final block b) {
    this.<Variable>clear(b, ElementType.VARIABLE, this.variables);
    declaration_part _declaration = b.getDeclaration();
    variable_declaration_part _variable_decl = _declaration.getVariable_decl();
    boolean _notEquals = (!Objects.equal(_variable_decl, null));
    if (_notEquals) {
      declaration_part _declaration_1 = b.getDeclaration();
      variable_declaration_part _variable_decl_1 = _declaration_1.getVariable_decl();
      EList<variable_section> _sections = _variable_decl_1.getSections();
      for (final variable_section section : _sections) {
        variable_identifier_list _identifiers = section.getIdentifiers();
        EList<String> _names = _identifiers.getNames();
        for (final String name : _names) {
          {
            type _type = section.getType();
            Type type = this.getType(b, _type);
            Variable _variable = new Variable(name, type, false, b, ElementType.VARIABLE);
            this.<Variable>addElement(b, _variable, this.variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
          }
        }
      }
    }
  }
  
  public boolean checkVariable(final block b, final variable v, final boolean isAssignment) {
    boolean isValid = true;
    boolean _equals = Objects.equal(v, null);
    if (_equals) {
      return true;
    }
    Set<Variable> _get = this.variables.get(b);
    String _name = v.getName();
    Variable _variable = new Variable(_name);
    Variable searchVariable = PascalValidator.<Variable>search(_get, _variable);
    boolean _equals_1 = Objects.equal(searchVariable, null);
    if (_equals_1) {
      isValid = false;
      this.insertError(v, this.VARIABLE_WAS_NOT_DECLARED, ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
    } else {
      this.removeError(v, ErrorType.NOT_DECLARATION);
      if (isAssignment) {
        boolean _equals_2 = Objects.equal(searchVariable.type, ElementType.CONSTANT);
        if (_equals_2) {
          isValid = false;
          this.insertError(v, this.CONSTANTS_CANNOT_BE_ASSIGNED, ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
        } else {
          this.removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
        }
      }
    }
    return isValid;
  }
  
  public void checkAbstraction(final block b, final Procedure proc, final boolean functionOnly, final EObject object, final EStructuralFeature feature) {
    Set<Procedure> _get = this.abstracoes.get(b);
    Procedure abstractionFound = PascalValidator.searchWithTypeCoersion(_get, proc);
    boolean _equals = Objects.equal(abstractionFound, null);
    if (_equals) {
      Set<Procedure> _get_1 = this.abstracoes.get(b);
      for (final Procedure p : _get_1) {
        String _lowerCase = p.name.toLowerCase();
        String _lowerCase_1 = proc.name.toLowerCase();
        boolean _equals_1 = _lowerCase.equals(_lowerCase_1);
        if (_equals_1) {
          int _size = p.parameters.size();
          int _size_1 = proc.parameters.size();
          boolean _notEquals = (_size != _size_1);
          if (_notEquals) {
            int _size_2 = p.parameters.size();
            String _plus = (this.WRONG_NUMBER_OF_ARGUMENTS + Integer.valueOf(_size_2));
            String _plus_1 = (_plus + " received ");
            int _size_3 = proc.parameters.size();
            String _plus_2 = (_plus_1 + Integer.valueOf(_size_3));
            String _plus_3 = (_plus_2 + " arguments.");
            this.insertError(object, _plus_3, ErrorType.NOT_DECLARATION, feature);
          } else {
            Iterator<Variable> it1 = p.parameters.iterator();
            Iterator<Variable> it2 = proc.parameters.iterator();
            while ((it1.hasNext() && it2.hasNext())) {
              {
                Variable type1 = it1.next();
                Variable type2 = it2.next();
                Type _varType = type1.getVarType();
                Type _varType_1 = type2.getVarType();
                boolean _areTypesCompatibles = TypeInferer.areTypesCompatibles(_varType, _varType_1);
                boolean _not = (!_areTypesCompatibles);
                if (_not) {
                  this.insertError(object, (((("Incompatible types of arguments. It expected " + p.parameters) + " received ") + proc.parameters) + "."), ErrorType.NOT_DECLARATION, feature);
                  return;
                }
              }
            }
          }
          return;
        }
      }
      this.insertError(object, this.FUNCTION_WAS_NOT_DECLARED, ErrorType.NOT_DECLARATION, feature);
    } else {
      this.removeError(object, ErrorType.NOT_DECLARATION);
      if ((Objects.equal(abstractionFound.type, ElementType.PROCEDURE) && functionOnly)) {
        this.insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
      } else {
        this.removeError(object, ErrorType.FUNCTION_ONLY);
      }
    }
  }
  
  public void checkAbstractionCall(final block b, final function_designator function, final boolean functionOnly) {
    expression_list _expressions = function.getExpressions();
    boolean _notEquals = (!Objects.equal(_expressions, null));
    if (_notEquals) {
      expression_list _expressions_1 = function.getExpressions();
      EList<expression> _expressions_2 = _expressions_1.getExpressions();
      for (final expression e : _expressions_2) {
        this.checkExpression(b, e);
      }
    }
    Procedure _abstraction = this.getAbstraction(b, function);
    this.checkAbstraction(b, _abstraction, functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME);
  }
  
  public void checkFactor(final block b, final factor f) {
    variable _variable = f.getVariable();
    boolean _notEquals = (!Objects.equal(_variable, null));
    if (_notEquals) {
      variable _variable_1 = f.getVariable();
      this.checkVariable(b, _variable_1, false);
      boolean _containsKey = this.variables.containsKey(b);
      if (_containsKey) {
        Set<Variable> _get = this.variables.get(b);
        variable _variable_2 = f.getVariable();
        String _name = _variable_2.getName();
        Variable _variable_3 = new Variable(_name);
        Variable v = PascalValidator.<Variable>search(_get, _variable_3);
        if (((!Objects.equal(v, null)) && Objects.equal(v.getValue(), null))) {
          this.insertError(f, "Variable not initialized.", ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
        } else {
          this.removeError(f, ErrorType.NOT_INITIALIZED);
        }
      }
    } else {
      function_designator _function = f.getFunction();
      boolean _notEquals_1 = (!Objects.equal(_function, null));
      if (_notEquals_1) {
        function_designator _function_1 = f.getFunction();
        this.checkAbstractionCall(b, _function_1, true);
      } else {
        factor _not = f.getNot();
        boolean _notEquals_2 = (!Objects.equal(_not, null));
        if (_notEquals_2) {
          factor _not_1 = f.getNot();
          Type _type = this.getType(b, _not_1);
          String _realType = _type.getRealType();
          String _lowerCase = _realType.toLowerCase();
          boolean _equals = _lowerCase.equals(this.BOOLEAN);
          boolean _not_2 = (!_equals);
          if (_not_2) {
            factor _not_3 = f.getNot();
            Type _type_1 = this.getType(b, _not_3);
            String _plus = (this.CANNOT_CONVERT_MESSAGE + _type_1);
            String _plus_1 = (_plus + " to boolean.");
            this.insertError(f, _plus_1, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
          } else {
            this.removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
          }
          factor _not_4 = f.getNot();
          this.checkFactor(b, _not_4);
        } else {
          expression _expression = f.getExpression();
          boolean _notEquals_3 = (!Objects.equal(_expression, null));
          if (_notEquals_3) {
            expression _expression_1 = f.getExpression();
            this.checkExpression(b, _expression_1);
          }
        }
      }
    }
  }
  
  public void checkTerm(final block b, final term t) {
    boolean isBoolean = false;
    boolean isNumeric = false;
    EList<String> _operators = t.getOperators();
    boolean _notEquals = (!Objects.equal(_operators, null));
    if (_notEquals) {
      EList<String> _operators_1 = t.getOperators();
      for (final String op : _operators_1) {
        String _lowerCase = op.toLowerCase();
        boolean _equals = _lowerCase.equals("and");
        if (_equals) {
          isBoolean = true;
        } else {
          if ((!isBoolean)) {
            isNumeric = true;
          } else {
            this.insertError(t, this.INVALID_OPERATOR_FOR_BOOLEAN, ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);
            return;
          }
        }
      }
    }
    this.removeError(t, ErrorType.INVALID_OPERATOR);
    EList<factor> _factors = t.getFactors();
    for (final factor f : _factors) {
      {
        if (isBoolean) {
          Type _type = this.getType(b, f);
          String _realType = _type.getRealType();
          String _lowerCase_1 = _realType.toLowerCase();
          boolean _equals_1 = _lowerCase_1.equals(this.BOOLEAN);
          boolean _not = (!_equals_1);
          if (_not) {
            Type _type_1 = this.getType(b, f);
            String _plus = (this.CANNOT_CONVERT_MESSAGE + _type_1);
            String _plus_1 = (_plus + " to boolean.");
            this.insertError(t, _plus_1, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);
          } else {
            this.removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
          }
        } else {
          if (isNumeric) {
            Type _type_2 = this.getType(b, f);
            int _typeWeight = TypeInferer.getTypeWeight(_type_2);
            boolean _equals_2 = (_typeWeight == (-1));
            if (_equals_2) {
              Type _type_3 = this.getType(b, f);
              String _plus_2 = (this.CANNOT_CONVERT_MESSAGE + _type_3);
              String _plus_3 = (_plus_2 + " to numeric.");
              this.insertError(t, _plus_3, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);
            } else {
              this.removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
            }
          }
        }
        this.checkFactor(b, f);
      }
    }
  }
  
  public void checkExpression(final block b, final expression expr) {
    EList<simple_expression> _expressions = expr.getExpressions();
    for (final simple_expression s : _expressions) {
      {
        boolean isBoolean = false;
        boolean isNumeric = false;
        String _prefixOperator = s.getPrefixOperator();
        boolean _notEquals = (!Objects.equal(_prefixOperator, null));
        if (_notEquals) {
          isNumeric = true;
        }
        EList<String> _operators = s.getOperators();
        boolean _notEquals_1 = (!Objects.equal(_operators, null));
        if (_notEquals_1) {
          EList<String> _operators_1 = s.getOperators();
          for (final String op : _operators_1) {
            String _lowerCase = op.toLowerCase();
            boolean _equals = _lowerCase.equals("or");
            if (_equals) {
              isBoolean = true;
            } else {
              if ((!isBoolean)) {
                isNumeric = true;
              } else {
                this.insertError(s, this.INVALID_OPERATOR_FOR_BOOLEAN, ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);
                return;
              }
            }
          }
        }
        if ((isNumeric && isBoolean)) {
          this.insertError(s, "Only numeric types are allowed in this expression.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);
        } else {
          this.removeError(s, ErrorType.INVALID_OPERATOR);
          EList<EObject> _terms = s.getTerms();
          for (final EObject obj : _terms) {
            if ((obj instanceof term)) {
              term t = ((term) obj);
              if (isBoolean) {
                Type _type = this.getType(b, t);
                String _realType = _type.getRealType();
                String _lowerCase_1 = _realType.toLowerCase();
                boolean _equals_1 = _lowerCase_1.equals(this.BOOLEAN);
                boolean _not = (!_equals_1);
                if (_not) {
                  Type _type_1 = this.getType(b, t);
                  String _plus = (this.CANNOT_CONVERT_MESSAGE + _type_1);
                  String _plus_1 = (_plus + " to boolean.");
                  this.insertError(s, _plus_1, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
                } else {
                  this.removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
                }
              } else {
                if (isNumeric) {
                  Type _type_2 = this.getType(b, t);
                  int _typeWeight = TypeInferer.getTypeWeight(_type_2);
                  boolean _equals_2 = (_typeWeight == (-1));
                  if (_equals_2) {
                    Type _type_3 = this.getType(b, t);
                    String _plus_2 = (this.CANNOT_CONVERT_MESSAGE + _type_3);
                    String _plus_3 = (_plus_2 + " to numeric.");
                    this.insertError(s, _plus_3, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
                  } else {
                    this.removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
                  }
                }
              }
              this.checkTerm(b, t);
            } else {
              if ((!isNumeric)) {
                this.insertError(s, "Only numeric types are allowed.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
              } else {
                this.removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
              }
            }
          }
        }
      }
    }
  }
  
  public Boolean checkConstant(final block b, final constant const_) {
    boolean _xifexpression = false;
    String _name = const_.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      boolean _xblockexpression = false;
      {
        Set<Variable> _get = this.variables.get(b);
        String _name_1 = const_.getName();
        Variable _variable = new Variable(_name_1);
        Variable searchVariable = PascalValidator.<Variable>search(_get, _variable);
        boolean _xifexpression_1 = false;
        boolean _equals = Objects.equal(searchVariable, null);
        if (_equals) {
          _xifexpression_1 = this.insertError(const_, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
        } else {
          boolean _xblockexpression_1 = false;
          {
            this.removeError(const_, ErrorType.NOT_DECLARATION);
            boolean _notEquals_1 = (!Objects.equal(searchVariable.type, ElementType.CONSTANT));
            if (_notEquals_1) {
              this.insertError(const_, this.ONLY_CONSTANTS_ARE_ALLOWED, ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
            } else {
              this.removeError(const_, ErrorType.CONSTANT_ONLY);
            }
            boolean _xifexpression_2 = false;
            if (((!Objects.equal(const_.getOpterator(), null)) && (TypeInferer.getTypeWeight(searchVariable.getVarType()) < 0))) {
              _xifexpression_2 = this.insertError(const_, this.VARIABLE_IS_NOT_A_NUMBER, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.CONSTANT__NAME);
            } else {
              this.removeError(const_, ErrorType.TYPE_CONVERSION_ERROR);
            }
            _xblockexpression_1 = _xifexpression_2;
          }
          _xifexpression_1 = _xblockexpression_1;
        }
        _xblockexpression = _xifexpression_1;
      }
      _xifexpression = _xblockexpression;
    }
    return Boolean.valueOf(_xifexpression);
  }
  
  public void checkStatement(final block b, final statement stmt) {
    simple_statement _simple = stmt.getSimple();
    boolean _notEquals = (!Objects.equal(_simple, null));
    if (_notEquals) {
      simple_statement simple = stmt.getSimple();
      assignment_statement _assignment = simple.getAssignment();
      boolean _notEquals_1 = (!Objects.equal(_assignment, null));
      if (_notEquals_1) {
        assignment_statement _assignment_1 = simple.getAssignment();
        variable _variable = _assignment_1.getVariable();
        boolean _checkVariable = this.checkVariable(b, _variable, true);
        if (_checkVariable) {
          assignment_statement _assignment_2 = simple.getAssignment();
          variable _variable_1 = _assignment_2.getVariable();
          Type variableType = this.getType(b, _variable_1);
          assignment_statement _assignment_3 = simple.getAssignment();
          expression _expression = _assignment_3.getExpression();
          Type expressionType = this.getType(b, _expression);
          boolean _areTypesCompatibles = TypeInferer.areTypesCompatibles(variableType, expressionType);
          boolean _not = (!_areTypesCompatibles);
          if (_not) {
            assignment_statement _assignment_4 = simple.getAssignment();
            this.insertError(_assignment_4, ((((this.CANNOT_CONVERT_TYPE + expressionType) + " to ") + variableType) + "."), ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
          } else {
            assignment_statement _assignment_5 = simple.getAssignment();
            this.removeError(_assignment_5, ErrorType.TYPE_CONVERSION_ERROR);
          }
          assignment_statement _assignment_6 = simple.getAssignment();
          expression _expression_1 = _assignment_6.getExpression();
          this.checkExpression(b, _expression_1);
          Set<Variable> _get = this.variables.get(b);
          assignment_statement _assignment_7 = simple.getAssignment();
          variable _variable_2 = _assignment_7.getVariable();
          String _name = _variable_2.getName();
          Variable _variable_3 = new Variable(_name);
          Variable v = PascalValidator.<Variable>search(_get, _variable_3);
          boolean _notEquals_2 = (!Objects.equal(v, null));
          if (_notEquals_2) {
            v.setValue(Integer.valueOf(0));
          }
        }
      } else {
        function_designator _function = simple.getFunction();
        boolean _notEquals_3 = (!Objects.equal(_function, null));
        if (_notEquals_3) {
          function_designator _function_1 = simple.getFunction();
          this.checkAbstractionCall(b, _function_1, false);
        } else {
          String _function_noargs = simple.getFunction_noargs();
          boolean _notEquals_4 = (!Objects.equal(_function_noargs, null));
          if (_notEquals_4) {
            Set<Procedure> _get_1 = this.abstracoes.get(b);
            String _function_noargs_1 = simple.getFunction_noargs();
            ArrayList<Variable> _arrayList = new ArrayList<Variable>();
            Procedure _procedure = new Procedure(_function_noargs_1, _arrayList);
            Procedure _search = PascalValidator.<Procedure>search(_get_1, _procedure);
            boolean _notEquals_5 = (!Objects.equal(_search, null));
            if (_notEquals_5) {
              this.removeError(simple, ErrorType.NOT_DECLARATION);
            } else {
              this.insertError(simple, this.PROCEDURE_WAS_NOT_DECLARED, ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
            }
          }
        }
      }
    } else {
      structured_statement _structured = stmt.getStructured();
      boolean _notEquals_6 = (!Objects.equal(_structured, null));
      if (_notEquals_6) {
        structured_statement structured = stmt.getStructured();
        compound_statement _compound = structured.getCompound();
        boolean _notEquals_7 = (!Objects.equal(_compound, null));
        if (_notEquals_7) {
          compound_statement compound = structured.getCompound();
          statement_sequence _sequence = compound.getSequence();
          this.checkStatements(b, _sequence);
        } else {
          repetitive_statement _repetitive = structured.getRepetitive();
          boolean _notEquals_8 = (!Objects.equal(_repetitive, null));
          if (_notEquals_8) {
            repetitive_statement repetitive = structured.getRepetitive();
            repeat_statement _repeat = repetitive.getRepeat();
            boolean _notEquals_9 = (!Objects.equal(_repeat, null));
            if (_notEquals_9) {
              repeat_statement _repeat_1 = repetitive.getRepeat();
              statement_sequence _sequence_1 = _repeat_1.getSequence();
              this.checkStatements(b, _sequence_1);
              repeat_statement _repeat_2 = repetitive.getRepeat();
              expression _expression_2 = _repeat_2.getExpression();
              this.checkExpression(b, _expression_2);
            }
          }
        }
      }
    }
  }
  
  public void checkStatements(final block b, final statement_sequence sequence) {
    EList<statement> _statements = sequence.getStatements();
    for (final statement stmt : _statements) {
      this.checkStatement(b, stmt);
    }
  }
  
  public void checkBlock(final block b) {
    statement_part _statement = b.getStatement();
    statement_sequence _sequence = _statement.getSequence();
    this.checkStatements(b, _sequence);
  }
  
  @Check
  public Object preencherTabela(final program prog) {
    Object _xblockexpression = null;
    {
      program_heading _heading = prog.getHeading();
      String name = _heading.getName();
      Object _xifexpression = null;
      boolean _containsKey = PascalValidator.tabela_de_simbolos.containsKey(name);
      boolean _not = (!_containsKey);
      if (_not) {
        Object _xblockexpression_1 = null;
        {
          HashMap<String, Object> _hashMap = new HashMap<String, Object>();
          PascalValidator.tabela_de_simbolos.put(name, _hashMap);
          Map<String, Object> _get = PascalValidator.tabela_de_simbolos.get(name);
          _get.put("variables", this.variables);
          Map<String, Object> _get_1 = PascalValidator.tabela_de_simbolos.get(name);
          _get_1.put("abstractions", this.abstracoes);
          Map<String, Object> _get_2 = PascalValidator.tabela_de_simbolos.get(name);
          _get_2.put("types", this.types);
          Map<String, Object> _get_3 = PascalValidator.tabela_de_simbolos.get(name);
          _xblockexpression_1 = _get_3.put("calculatedTypes", this.calculatedTypes);
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public void iniciarChecks(final block b) {
    this.checkTypeRedeclaration(b);
    this.checkAbstractionRedeclaration(b);
    this.checkConstantRedeclaration(b);
    this.checkVariableRedeclaration(b);
    this.checkBlock(b);
  }
  
  @Check
  public void showError(final EObject obj) {
    boolean _containsKey = this.ListaDeErros.containsKey(obj);
    if (_containsKey) {
      Set<org.xtext.ufcg.compiladores.validation.Error> _get = this.ListaDeErros.get(obj);
      for (final org.xtext.ufcg.compiladores.validation.Error err : _get) {
        String _message = err.getMessage();
        EStructuralFeature _feature = err.getFeature();
        this.error(_message, obj, _feature, (-1));
      }
    }
  }
}
